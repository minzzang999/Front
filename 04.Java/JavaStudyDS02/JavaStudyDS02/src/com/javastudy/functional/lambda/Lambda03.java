package com.javastudy.functional.lambda;

// 메서드 참조
/* 람다식을 이용해 추상 메서드를 직접 구현하는 대신 이미 완성된 메서드를 참조해서
 * 인터페이스를 구현하는 방법이 있다. 메서드 참조에는 인스턴스 메서드 참조와 
 * 스태틱 메서드를 참조하는 방식이 있다. 이외에도 추상 메서드의 첫 번째 매개 변수로
 * 넘어오는 인스턴스의 메서드를 참조하는 방법도 있다.   
 **/
interface I01{
	void add();
}

class M01 {
	void plus() {
		System.out.println("plus");
	}
}

class M02 {
	static void plus() {
		System.out.println("static plus");
	}
}

public class Lambda03 {

	public static void main(String[] args) {
	
		// 익명 클래스 방식으로 인스턴스 메서드 사용
		I01 i01 = new I01() {
			@Override
			public void add() {
				/* M01 클래스의 인스턴스 메서드를 사용하려면
				 * 먼저 인스턴스를 생성해야 한다.
				 **/
				M01 m = new M01();
				m.plus();
			}
		};
		i01.add();
		
		// 람다식 방식으로 인스턴스 메서드 사용
		I01 i02 = () -> {
			M01 m = new M01();
			m.plus();
		};
		i02.add();
		
		/* 인스턴스 메서드 참조 방식으로 인스턴스 메서드 사용
		 * M01 클래스의 인스턴스 메서드를 사용하려면 먼저 인스턴스를 생성해야 한다.
		 * 인스턴스 메서드 참조는 더블콜론(::) 연산자(참조 연산자)를 이용해 
		 * 다음과 같이 인스턴스 메서드를 참조해 인터페이스를 구현할 수 있다. 
		 * 
		 * "인스턴스참조변수::인스턴스메서드"
		 * 
		 * 아래에서 I01 i03 = m01::plus; 코드의 의미는 인터페이스 I01
		 * 내부의 add() 메서드는 참조 변수 m01이 참조하는 인스턴스 내부의
		 * plus() 메서드와 동일하다는 의미이다. 한 가지 주의 할 점은 이 두 
		 * 메서드의 매개 변수 타입과 반환 타입이 동일해야 한다는 것이다.
		 **/		
		M01 m01 = new M01();
		I01 i03 = m01::plus;
		i03.add();
		
		
		// 익명 클래스 방식으로 스태틱 메서드 사용
		I01 i04 = new I01() {
			@Override
			public void add() {
				// M02 클래스의 스태틱 메서드는 클래스 이름으로 접근			
				M02.plus();
			}
		};
		i04.add();
		
		// 람다식 방식으로 스태틱 메서드 사용
		I01 i05 = () -> {
			M02.plus();
		};
		i05.add();
		
		/* 스태틱 메서드 참조 방식으로 스태틱 메서드 사용
		 * M01 클래스의 스태틱 메서드는 클래스 이름으로 접근할 수 있다.
		 * 스태틱 메서드 참조는 더블콜론(::) 연산자(참조 연산자)를 이용해 
		 * 다음과 같이 스택틱 메서드를 참조해 인터페이스를 구현할 수 있다. 
		 * 
		 * "클래스이름::스태틱메서드"
		 * 
		 * 아래에서 I01 i06 = M02::plus; 코드의 의미는 인터페이스 I01
		 * 내부의 add() 메서드는 클래스 M02 내부의 스태틱 메서드인 plus()
		 * 메서드와 동일하다는 의미이다. 한 가지 주의 할 점은 이 두 메서드의
		 * 매개 변수 타입과 반환 타입이 동일해야 한다는 것이다.
		 **/	
		I01 i06 = M02::plus;
		i06.add();
	}
}

