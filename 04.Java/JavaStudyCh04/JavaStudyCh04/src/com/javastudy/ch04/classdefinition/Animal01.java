package com.javastudy.ch04.classdefinition;

// 속성과 메서드를 가지는 클래스 정의하고 사용하기
public class Animal01 {
	
	// 객체가 가지는 데이터를 속성(Property) 또는 필드(Field)라고 부른다.
	String name;
	int age;	
	String sound;
	String kind;	
	
	/* 객체지향 프로그래밍에서는 객체가 가지는 동작(기능)을 메서드(Method)라고 부른다.
	 * 메서드는 객체가 가지는 특정 동작을 구현하기 위해서 작성한 코드의 묶음이다.
	 * 여러 곳에서 반복적으로 사용될 수 있는 코드를 묶어서 메서드로 만들어 놓으면 
	 * 그 기능이 필요한 곳에 코드를 중복해서 사용하지 않고 메서드를 사용하면 되므로
	 * 코드의 중복을 최소화 하고 코드의 재사용성을 높을 수 있다는 장점이 있다.   
	 * 
	 * 메서드를 정의할 때는 그 메서드가 제공하는 기능을 정의하고 그 기능을 구현하기
	 * 위해서 외부에서 데이터가 입력되어야 하는지와 메서드가 실행을 완료한 후에
	 * 자신을 호출한 곳으로 돌아갈 때 어떤 데이터를 외부에 돌려줘야 하는지를 결정해서
	 * 메서드의 선언부를 작성해야 한다.   
	 * 
	 * 아래의 eat() 메서드는 동물이 먹는 모습을 텍스트로 출력하는 메서드로 이 메서드가
	 * 실행되기 위해서 외부로부터 받아야할 데이터는 필요 없기 때문에 메서드의 () 안을
	 * 비어 놓았다. 또한 메서드 이름 앞에 지정해야 할 반환 타입은 이 메서드가 실행을 
	 * 완료한 후에 외부에 돌려줘야할 데이터가 없다는 의미로 void를 지정하고 있다. 
	 **/
	void eat() {
		System.out.println(name + "이(가) 먹습니다.");
	}
	
	/* 아래의 sleep() 메서드는 어떤 이름을 가진 동물이 잠을 자는지를 출력하는
	 * 메서드로 이름을 외부에서 받기 위해서 메서드의 () 안에 이름을 받을 수 있도록
	 * String 타입의 매개변수(Parameter)를 정의하고 있다. 그리고 메서드 내부에서
	 * 출력만 하면 되므로 외부에 돌려줄 데이터가 없기 때문에 메서드 이름 앞에 지정해야
	 * 할 반환 타입은 void를 지정하고 있다. 
	 **/
	void sleep(String name) {
		System.out.println(name + "이(가) 잠을 잡니다.");
	}
	
	/* 아래 play() 메서드는 어떤 이름을 가진 동물이 즐겁게 노는지를 문자열로 반환하는
	 * 메서드로 클래스 내부 데이터를 사용해 외부에 반환되는 데이터를 만들기 때문에
	 * 메서드 () 안을 비어 놓았다. 그리고 문자열을 반환하기 위해서 메서드 이름 앞에
	 * 지정해야 할 반환타입은 String 타입을 지정하고 있다.  
	 **/
	String play() {
		return name + "이(가) 즐겁게 장난을 칩니다.";
	}
	
	/* 아래의 cry() 메서드는 어떤 이름을 가진 어떤 종류의 동물이 어떤 소리로 우는지를 
	 * 문자열로 반환하는 메서드로 동물의 이름은 클래스 내부 데이터를 사용하지만 동물의
	 * 종류와 울음 소리는 외부로부터 받기 위해서 메서드의 () 안에 String 타입의 매개변수
	 * (Parameter)를 정의하고 있다. 그리고 최종 결과로 문자열을 반환하기 위해서 
	 * 메서드 이름 앞에 지정해야 할 반환타입은 String 타입을 지정하고 있다.    
	 **/
	String cry(String kind, String sound) {
		return name + "은(는) " + kind + "(으)로" + sound;		
	}
	
	/* 이 클래스는 별도로 상속 받는 클래스를 지정하지 않았기 때문에 컴파일러에 의해 
	 * 자바의 최상위 조상인 Object 클래스를 자동으로 상속 받게 되며 아래와 같이
	 * 콘솔에 출력해 주는 println() 메서드에 객체를 참조하는 참조 변수만 기술해도
	 * Object 클래스로부터 상속받은 toString()이 자동으로 호출 된다. 참고로
	 * toString() 메서드는 현재 객체의 상태를 문자열로 반환하는 메서드 이다.
	 * 
	 * 아래는 Object 클래스로부터 상속받은 toString() 메서드를 이 클래스에 맞게
	 * 다시 정의(수정) 했기 때문에  Object로부터 상속 받은 toString() 메서드가
	 * 호출되는 것이 아니라 이 클래스에서 다시 정의한 아래의 toString()이 호출 된다. 
	 * 
	 * Animal01 animal = new Animal01();
	 * System.out.println(animal);
	 * 
	 * 상속 받은 부모의 메서드와 동일한 이름과 특징(반환타입, 매개변수)을 지닌 메서드를
	 * 선언하게 되면 이 클래스로부터 생성된 객체는 부모의 메서드가 호출되는 것이 아니라
	 * 자신의 메서드가 호출되는데 이러한 기법을 오버라이딩(Overriding) 이라 한다.
	 * 오버라이딩은 부모로부터 물려받은 메서드를 자식 대에서 필요한 기능을 추가 하거나 
	 * 수정하는 것을 의미하며 이는 부모로부터 상속 받은 메서드를 자식이 필요에 의해서
	 * 메서드의 기능을 다시 정의하는 것이므로 메서드 재정의라고도 한다. 
	 * 
	 * 아래와 같이 메서드 이름 앞에 이 메서드가 실행을 완료한 후 호출한 곳으로
	 * 다시 돌아갈 때 가지고 갈 데이터 타입을 지정하는데 이 메서드는 현재 인스턴스의
	 * 상태를 문자열로 반환하는 기능을 제공하는 메서드이므로 String을 지정했다.
	 **/
	@Override
	public String toString() {
		return name + "은(는) " + kind + "(으)로 " + age + "살 입니다.";
	}
}
